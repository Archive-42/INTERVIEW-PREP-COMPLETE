<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>w1d1-b</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h2 id="behavioral">Behavioral</h2>
<ul>
<li>Tell me about yourself</li>
<li>What three things are you working on to improve your overall effectiveness?</li>
<li>You have been assigned to a project in a new technology you haven’t worked with before. How do you get started? Have you ever done this before? How did it go?</li>
</ul>
<h2 id="easy">Easy</h2>
<p>Given an array of length N, with integer values between 0 and N (not including 0 or N), return any integer that appears in the array more than once, i.e. </p>
<pre><code>[ 1, 2, 3, 3, 4 ] =&gt; 3
[ 3, 1, 2, 2, 5, 5 ] =&gt; 2 or 5 (either is fine)
[ 0, 1, 2 ] =&gt; invalid input (can’t have 0)</code></pre>
<h3 id="time-and-space-complexity">Time and Space Complexity</h3>
<ul>
<li>O(n) time</li>
<li>Easy: O(n) space</li>
<li>Hard: O(1) space</li>
</ul>
<h3 id="solution">Solution</h3>
<p>For each number (K), multiply the value at index K by -1. If the value at that index is already negative, that is the duplicate value.</p>
<pre><code>[ 3, 1, 1, 2 ] =&gt; [ 3, 1, 1, -2 ]
[ 3, 1, 1, -2 ] =&gt; [ 3, -1, 1, -2 ]
[ 3, -1, 1, -2 ] =&gt; [ 3, -1, 1, -2 ] =&gt; return 1</code></pre>
<h2 id="medium">Medium</h2>
<p>Given a binary tree, return all root-to-leaf paths. For example, given the following binary tree:</p>
<pre><code>  1
 /   \
2     3
 \
  5</code></pre>
<p>All root-to-leaf paths are: <code>["1-&gt;2-&gt;5", "1-&gt;3"]</code></p>
<h3 id="solution-1">Solution</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">var</span> binaryTreePaths <span class="op">=</span> <span class="kw">function</span>(root) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">var</span> paths <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="cf">if</span>(<span class="op">!</span>root) <span class="cf">return</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="cf">if</span>(<span class="va">root</span>.<span class="at">left</span> <span class="op">==</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> <span class="va">root</span>.<span class="at">right</span> <span class="op">==</span> <span class="kw">null</span>)<span class="op">{</span></a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="cf">if</span>(<span class="va">paths</span>.<span class="at">length</span> <span class="op">==</span> <span class="dv">0</span>) <span class="cf">return</span> [<span class="st">&quot;&quot;</span><span class="op">+</span><span class="va">root</span>.<span class="at">val</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb4-6" title="6">        <span class="cf">else</span> <span class="cf">return</span> <span class="va">root</span>.<span class="at">val</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="op">}</span> </a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="cf">else</span><span class="op">{</span></a>
<a class="sourceLine" id="cb4-9" title="9">        <span class="cf">if</span>(<span class="va">root</span>.<span class="at">left</span>) </a>
<a class="sourceLine" id="cb4-10" title="10">          <span class="at">binaryTreePaths</span>(<span class="va">root</span>.<span class="at">left</span>).<span class="at">forEach</span>(<span class="kw">function</span>(lp) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-11" title="11">            <span class="va">paths</span>.<span class="at">push</span>(<span class="va">root</span>.<span class="at">val</span> <span class="op">+</span> <span class="st">&quot;-&gt;&quot;</span> <span class="op">+</span> lp)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-12" title="12">          <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-13" title="13">        <span class="cf">if</span>(<span class="va">root</span>.<span class="at">right</span>) </a>
<a class="sourceLine" id="cb4-14" title="14">          <span class="at">binaryTreePaths</span>(<span class="va">root</span>.<span class="at">right</span>).<span class="at">forEach</span>(<span class="kw">function</span>(rp) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-15" title="15">            <span class="va">paths</span>.<span class="at">push</span>(<span class="va">root</span>.<span class="at">val</span> <span class="op">+</span> <span class="st">&quot;-&gt;&quot;</span> <span class="op">+</span> rp)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-16" title="16">          <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb4-18" title="18"></a>
<a class="sourceLine" id="cb4-19" title="19">    <span class="cf">return</span> paths<span class="op">;</span></a>
<a class="sourceLine" id="cb4-20" title="20"><span class="op">};</span></a></code></pre></div>
<h2 id="hard">Hard</h2>
<p>Given a string s, find the longest palindromic substring in s.</p>
<p>Example:</p>
<p>Input: “babad” Output: “bab” Note: “aba” is also a valid answer.</p>
<p>Example: Input: “cbbd” Output: “bb”</p>
<h3 id="solutions">Solutions</h3>
<h4 id="non-optimal-solution---best-case-on-worst-case-on2">Non-optimal Solution - best case <code>O(N)</code>, worst case <code>O(N^2)</code></h4>
<p>This is a non optimal (see below for optimal solution), but much easier to understand solution. It uses the following algorithm. At a position of the string, it compares the character at the left and right to see if they’re the same. If they are, it looks one character further out on each side and compares them. And so on until it reaches an end of the string or finds the two characters are different. It does this at each position of the string, finding the longest palindrome centered around each position, keeping track of which is longest overall.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">def</span> find_longest_palindrome(s)  </a>
<a class="sourceLine" id="cb5-2" title="2">  longest = <span class="st">&quot;&quot;</span>  </a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="dv">0</span>.upto s.length <span class="kw">do</span> |i|  </a>
<a class="sourceLine" id="cb5-4" title="4">   odd = palindrome_at_position(s, i, i)  </a>
<a class="sourceLine" id="cb5-5" title="5">   longest = odd <span class="kw">if</span> odd.length &gt; longest.size  </a>
<a class="sourceLine" id="cb5-6" title="6">   <span class="co"># handle even length palindromes  </span></a>
<a class="sourceLine" id="cb5-7" title="7">   even = palindrome_at_position(s, i, i+<span class="dv">1</span>)  </a>
<a class="sourceLine" id="cb5-8" title="8">   longest = even <span class="kw">if</span> even.length &gt; longest.size  </a>
<a class="sourceLine" id="cb5-9" title="9">  <span class="kw">end</span>  </a>
<a class="sourceLine" id="cb5-10" title="10">  longest  </a>
<a class="sourceLine" id="cb5-11" title="11"> <span class="kw">end</span></a>
<a class="sourceLine" id="cb5-12" title="12"> </a>
<a class="sourceLine" id="cb5-13" title="13"> <span class="kw">def</span> palindrome_at_position(s, left, right)  </a>
<a class="sourceLine" id="cb5-14" title="14">  palindrome = <span class="st">&quot;&quot;</span>  </a>
<a class="sourceLine" id="cb5-15" title="15">  <span class="kw">while</span> (right &lt; s.length &amp;&amp;  </a>
<a class="sourceLine" id="cb5-16" title="16">      left &gt;= <span class="dv">0</span> &amp;&amp;  </a>
<a class="sourceLine" id="cb5-17" title="17">      s[left] == s[right])  </a>
<a class="sourceLine" id="cb5-18" title="18">   palindrome = s[left,(right-left+<span class="dv">1</span>)]  </a>
<a class="sourceLine" id="cb5-19" title="19">   left -= <span class="dv">1</span>  </a>
<a class="sourceLine" id="cb5-20" title="20">   right += <span class="dv">1</span>  </a>
<a class="sourceLine" id="cb5-21" title="21">  <span class="kw">end</span>  </a>
<a class="sourceLine" id="cb5-22" title="22">  palindrome   </a>
<a class="sourceLine" id="cb5-23" title="23"> <span class="kw">end</span>  </a></code></pre></div>
<h4 id="optimal-solution---linear-time-on">Optimal Solution - Linear time O(n)</h4>
<p>Here is a linear time solution. Guaranteed to be 2N or fewer comparisons.</p>
<p>This solution is similar to the first solution but it uses findings from previous palindrome length calculations to reduce how much processing it has to do. It takes advantage of the fact that if you know there is a large palindrome centered around one character, the characters to the immediate right of that character must be at the center of palindromes at least as long as the palindromes centered around characters to the immediate left.</p>
<p>Example: <code>"abcbcbadef"</code> When you’re looking at the ‘b’ at index 3, you calculate that it’s the center of a palindrome 7 characters long (spanning out 3 characters in each direction). So when you go to calculate the palindrome centered around index 4 (the second ‘c’), you know that it must be at least as long as the palindrome you’ve already calculated at index 2 (the first ‘c’) which is 3 characters long. And seeing that those 3 characters don’t take you past the end of the palindrome centered around ‘b’ at index 3, you know that it can only be 3 characters long. And similarly when you look at index 5 (the third ‘b’), you know that its palindrome must be the same as the palindrome at index 1 (the first ‘b’), which is only 1 character long.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode ruby"><code class="sourceCode ruby"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">def</span> longest_palindrome(str)  </a>
<a class="sourceLine" id="cb6-2" title="2">  palindrome_lengths = {}  </a>
<a class="sourceLine" id="cb6-3" title="3">  center = right = <span class="dv">0</span>  </a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="co"># This gsub changes a string &quot;abc&quot; into &quot;~a~b~c~&quot; </span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="co"># This is done to avoid the problem of even length palindromes    </span></a>
<a class="sourceLine" id="cb6-6" title="6">  processed_str = str.gsub(<span class="ot">/(\w|$)/</span>, <span class="st">&#39;~\1&#39;</span>)  </a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="dv">0</span>.upto (processed_str.length - <span class="dv">1</span>) <span class="kw">do</span> |i|  </a>
<a class="sourceLine" id="cb6-8" title="8">    i_mirror = center - (i - center)  </a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="kw">if</span> (right &gt; i)  </a>
<a class="sourceLine" id="cb6-10" title="10">      palindrome_lengths[i] = [right-i, palindrome_lengths[i_mirror]].min  </a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="kw">else</span>  </a>
<a class="sourceLine" id="cb6-12" title="12">      palindrome_lengths[i] = <span class="dv">0</span>  </a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb6-14" title="14">    <span class="kw">while</span> (processed_str[i + <span class="dv">1</span> + palindrome_lengths[i]] == processed_str[i - <span class="dv">1</span> - palindrome_lengths[i]])</a>
<a class="sourceLine" id="cb6-15" title="15">      palindrome_lengths[i] += <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-16" title="16">    <span class="kw">end</span></a>
<a class="sourceLine" id="cb6-17" title="17">    <span class="kw">if</span> (i + palindrome_lengths[i] &gt; right)  </a>
<a class="sourceLine" id="cb6-18" title="18">      center = i;  </a>
<a class="sourceLine" id="cb6-19" title="19">      right = center + palindrome_lengths[i];  </a>
<a class="sourceLine" id="cb6-20" title="20">    <span class="kw">end</span>  </a>
<a class="sourceLine" id="cb6-21" title="21">  <span class="kw">end</span>  </a>
<a class="sourceLine" id="cb6-22" title="22">  max = palindrome_lengths.values.max  </a>
<a class="sourceLine" id="cb6-23" title="23">  center_index = palindrome_lengths.key(max)  </a>
<a class="sourceLine" id="cb6-24" title="24">  str[(center_index - max)/<span class="dv">2</span>, max]  </a>
<a class="sourceLine" id="cb6-25" title="25"><span class="kw">end</span></a></code></pre></div>
</body>
</html>
