<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>reverse_part_of_a_linked_list_via_recursion</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="reverse-part-of-a-linked-list-via-recusion">Reverse Part of a Linked List via Recusion</h1>
<p><strong>Translator: <a href="https://github.com/CarrieOn">CarrieOn</a></strong></p>
<p><strong>Author: <a href="https://github.com/labuladong">labuladong</a></strong></p>
<p>It’s easy to reverse a single linked list using iteration, however it’s kind of difficult to come up with a recursive solution. Furthermore, if only part of a linked list needs reversed, can you nail it with <strong>recursion</strong>?</p>
<p>If you haven’t known how to <strong>recursively reverse a single linked list</strong>, no worry, we will start right here and guide you step by step to a deeper level.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// node structure for a single linked list </span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">public</span> <span class="kw">class</span> ListNode {</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="dt">int</span> val;</a>
<a class="sourceLine" id="cb1-4" title="4">    ListNode next;</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="fu">ListNode</span>(<span class="dt">int</span> x) { val = x; }</a>
<a class="sourceLine" id="cb1-6" title="6">}</a></code></pre></div>
<p><br></p>
<p>To reverse part of a linked list means we only reverse elements in a specific interval and leave others untouched.</p>
<p><img src="../pictures/reverse_linked_list/title.png" /></p>
<p>Note: <strong>Index starts from 1</strong>. Two loops needed if solve via iteration: use one for-loop to find the mth element, and then use another for-loop to reverse elements between m and n. While in recursive solution, no loop at all.</p>
<p>Though iterative solution looks simple, you have to be careful with the details. On the contrary, recursive solution is quite elegant. Let’s start reversing a whole single linked list in the recursive way.</p>
<h3 id="recursively-reverse-a-whole-single-linked-list">1. Recursively reverse a whole single Linked List</h3>
<p>You may have already known the solution below.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1">ListNode <span class="fu">reverse</span>(ListNode head) {</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="kw">if</span> (head.<span class="fu">next</span> == <span class="kw">null</span>) <span class="kw">return</span> head;</a>
<a class="sourceLine" id="cb2-3" title="3">    ListNode last = <span class="fu">reverse</span>(head.<span class="fu">next</span>);</a>
<a class="sourceLine" id="cb2-4" title="4">    head.<span class="fu">next</span>.<span class="fu">next</span> = head;</a>
<a class="sourceLine" id="cb2-5" title="5">    head.<span class="fu">next</span> = <span class="kw">null</span>;</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="kw">return</span> last;</a>
<a class="sourceLine" id="cb2-7" title="7">}</a></code></pre></div>
<p>Do you feel lost in trying to understand code above? Well, you are not the only one. This algorithm is often used to show how clever and elegant recursion can be. Let’s dig into the code together.</p>
<p>For recursion, <strong>the most important thing is to clarify the definition of the recursive function</strong>. Specifically, we define <code>reverse</code> as follows:</p>
<p><strong>Input a node <code>head</code>, we will reverse the list starting from <code>head</code>, and return the new head node.</strong></p>
<p>After clarifying the definition, we look back at the problem. For example, we want to reverse the list below:</p>
<p><img src="../pictures/reverse_linked_list/1.jpg" /></p>
<p>So after calling <code>reverse(head)</code>, recursion happens:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb3-1" title="1">ListNode last = <span class="fu">reverse</span>(head.<span class="fu">next</span>);</a></code></pre></div>
<p>Did you just step into the messy details in recursion? Oops, it’s a wrong way, step back now! Focus on the recursion definition (which tells you what it does) to understand how recursive code works the wonder.</p>
<p><img src="../pictures/reverse_linked_list/2.jpg" /></p>
<p>After executing <code>reverse(head.next)</code>, the whole linked list becomes this:</p>
<p><img src="../pictures/reverse_linked_list/3.jpg" /></p>
<p>According to the definition of the recursive function, <code>reverse</code> needs to return the new head node, so we use variable <code>last</code> to mark it.</p>
<p>Let’s continue cracking the next piece of code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1">head.<span class="fu">next</span>.<span class="fu">next</span> = head;</a></code></pre></div>
<p><img src="../pictures/reverse_linked_list/4.jpg" /></p>
<p>Last work to do：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" title="1">head.<span class="fu">next</span> = <span class="kw">null</span>;</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">return</span> last;</a></code></pre></div>
<p><img src="../pictures/reverse_linked_list/5.jpg" /></p>
<p>The whole linked list is successfully reversed now. Amazing, isn’t it?</p>
<p>Last but not the least, there are two things in recursion you need to pay attention to:</p>
<ol type="1">
<li><p>Recursion needs a base case.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">if</span>(head.<span class="fu">next</span> == <span class="kw">null</span>) <span class="kw">return</span> head;</a></code></pre></div>
which means when there is only one node, after reversion, the head is still itself.</li>
<li><p>After reversion, the new head is <code>last</code>, and the former <code>head</code> becomes the last node, don’t forget to point its tail to null.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" title="1">head.<span class="fu">next</span> = <span class="kw">null</span>;</a></code></pre></div></li>
</ol>
<p>After understanding above, now we can proceed further, the problem below is actually an extend to the above solution.</p>
<h3 id="reverse-first-n-nodes">2. Reverse first N nodes</h3>
<p>This time we will implement a funtion below:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb8-1" title="1"><span class="co">// reverse first n nodes in a linked list (n &lt;= length of the list)</span></a>
<a class="sourceLine" id="cb8-2" title="2">ListNode <span class="fu">reverseN</span>(ListNode head, <span class="dt">int</span> n)</a></code></pre></div>
<p>Take below as an example, call <code>reverseN(head, 3)</code>:</p>
<p><img src="../pictures/reverse_linked_list/6.jpg" /></p>
<p>The idea is similar to reversing the whole linked list, only a few modifications needed:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb9-1" title="1">ListNode successor = <span class="kw">null</span>; <span class="co">// successor node</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="co">// reverse n nodes starting from head, and return new head</span></a>
<a class="sourceLine" id="cb9-4" title="4">ListNode <span class="fu">reverseN</span>(ListNode head, <span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="kw">if</span> (n == <span class="dv">1</span>) { </a>
<a class="sourceLine" id="cb9-6" title="6">        <span class="co">// mark the (n + 1)th node</span></a>
<a class="sourceLine" id="cb9-7" title="7">        successor = head.<span class="fu">next</span>;</a>
<a class="sourceLine" id="cb9-8" title="8">        <span class="kw">return</span> head;</a>
<a class="sourceLine" id="cb9-9" title="9">    }</a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="co">// starts from head.next, revers the first n - 1 nodes</span></a>
<a class="sourceLine" id="cb9-11" title="11">    ListNode last = <span class="fu">reverseN</span>(head.<span class="fu">next</span>, n - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb9-12" title="12"></a>
<a class="sourceLine" id="cb9-13" title="13">    head.<span class="fu">next</span>.<span class="fu">next</span> = head;</a>
<a class="sourceLine" id="cb9-14" title="14">    <span class="co">// link the new head to successor</span></a>
<a class="sourceLine" id="cb9-15" title="15">    head.<span class="fu">next</span> = successor;</a>
<a class="sourceLine" id="cb9-16" title="16">    <span class="kw">return</span> last;</a>
<a class="sourceLine" id="cb9-17" title="17">}    </a></code></pre></div>
<p>Main differences:</p>
<ol type="1">
<li>Base case <code>n == 1</code>, if reverse only one element, then new head is itself, meanwhile <strong>remember to mark the successor node</strong>.</li>
<li>In previouse solution, we set <code>head.next</code> directly to null, because after reversing the whole list, head becoms the last node. But now <code>head</code> may not be the last node after reversion, so we need mark <code>successor</code> (the (n+1)th node), and link it to <code>head</code> after reversion.</li>
</ol>
<p><img src="../pictures/reverse_linked_list/7.jpg" /></p>
<p>OK, now we are pretty close to reversing part of the linked list.</p>
<h3 id="reverse-part-of-a-linked-list">3. Reverse part of a linked list</h3>
<p>Given an interval <code>[m,n]</code> (index starts from 1), only reverse elements in this section.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb10-1" title="1">ListNode <span class="fu">reverseBetween</span>(ListNode head, <span class="dt">int</span> m, <span class="dt">int</span> n)</a></code></pre></div>
<p>First, if <code>m == 1</code>, it is equal to reversing the first <code>n</code> elements as we discussed just now.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb11-1" title="1">ListNode <span class="fu">reverseBetween</span>(ListNode head, <span class="dt">int</span> m, <span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb11-2" title="2">    <span class="co">// base case</span></a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="kw">if</span> (m == <span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb11-4" title="4">        <span class="co">// equals to reversing the first n nodes</span></a>
<a class="sourceLine" id="cb11-5" title="5">        <span class="kw">return</span> <span class="fu">reverseN</span>(head, n);</a>
<a class="sourceLine" id="cb11-6" title="6">    }</a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb11-8" title="8">}</a></code></pre></div>
<p>What if <code>m != 1</code>? If we take the index of the <code>head</code> as 1, then we need to reverse from the <code>mth</code> element. And what if we take the index of the <code>head.next</code> as 1? Then compared to <code>head.next</code>, the reverse section should start from <code>(m-1)th</code> element. And what about <code>head.next.next</code> …</p>
<p>Different from iteration, this is how we think in the recursive way, so our code should be:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb12-1" title="1">ListNode <span class="fu">reverseBetween</span>(ListNode head, <span class="dt">int</span> m, <span class="dt">int</span> n) {</a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="co">// base case</span></a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="kw">if</span> (m == <span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb12-4" title="4">        <span class="kw">return</span> <span class="fu">reverseN</span>(head, n);</a>
<a class="sourceLine" id="cb12-5" title="5">    }</a>
<a class="sourceLine" id="cb12-6" title="6">    head.<span class="fu">next</span> = <span class="fu">reverseBetween</span>(head.<span class="fu">next</span>, m - <span class="dv">1</span>, n - <span class="dv">1</span>);</a>
<a class="sourceLine" id="cb12-7" title="7">    <span class="kw">return</span> head;</a>
<a class="sourceLine" id="cb12-8" title="8">}</a></code></pre></div>
<p>Finally, we solved the problem we have talked about at the very beginning, happy ending!</p>
<h3 id="summary">4. Summary</h3>
<p>Compared to iteration, it is a little bit difficult to understand recursion, the tricks are: never bury yourself in the details, just focus on its clear definition, thus to gain a quick understanding of how it works and what it outputs.</p>
<p>For time complexity, iteration is O(1) while recursion is always O(N). For space complexity, iteration needs O(N) while recursion needs stack. Overall, iteration has a better performance. Solutions in this article provides you a good way to learn recursion.</p>
<p><strong>Mission</strong>: Stick to original high quality articles, and make algorithms easy to understand. Welcome to subscribe my Wechat public account <code>ID:labuladong</code> for latest articles.</p>
</body>
</html>
